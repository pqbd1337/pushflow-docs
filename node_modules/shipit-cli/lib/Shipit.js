"use strict";

exports.__esModule = true;
exports.default = void 0;

var _sshPool = require("ssh-pool");

var _streamLineWrapper = _interopRequireDefault(require("stream-line-wrapper"));

var _orchestrator = _interopRequireDefault(require("orchestrator"));

var _chalk = _interopRequireDefault(require("chalk"));

var _prettyHrtime = _interopRequireDefault(require("pretty-hrtime"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * An ExecResult returned when a command is executed with success.
 * @typedef {object} ExecResult
 * @property {Buffer} stdout
 * @property {Buffer} stderr
 * @property {ChildProcess} child
 */

/**
 * An ExecResult returned when a command is executed with success.
 * @typedef {object} MultipleExecResult
 * @property {Buffer} stdout
 * @property {Buffer} stderr
 * @property {ChildProcess[]} children
 */

/**
 * An ExecError returned when a command is executed with an error.
 * @typedef {Error} ExecError
 * @property {Buffer} stdout
 * @property {Buffer} stderr
 * @property {ChildProcess} child
 */

/**
 * Format orchestrator error.
 *
 * @param {Error} e
 * @returns {Error}
 */
function formatError(e) {
  if (!e.err) {
    return e.message;
  } // PluginError


  if (typeof e.err.showStack === 'boolean') {
    return e.err.toString();
  } // normal error


  if (e.err.stack) {
    return e.err.stack;
  } // unknown (string, number, etc.)


  return new Error(String(e.err)).stack;
}

class Shipit extends _orchestrator.default {
  constructor(options) {
    super();
    const defaultOptions = {
      stdout: process.stdout,
      stderr: process.stderr,
      log: console.log.bind(console)
    };
    this.config = {};
    this.globalConfig = {};
    this.options = _extends({}, defaultOptions, {}, options);
    this.environment = options.environment;
    this.initializeEvents();
    if (this.options.stdout === process.stdout) process.stdout.setMaxListeners(100);
    if (this.options.stderr === process.stderr) process.stderr.setMaxListeners(100);
  }
  /**
   * Initialize the `shipit`.
   *
   * @returns {Shipit} for chaining
   */


  initialize() {
    if (!this.globalConfig[this.environment]) throw new Error(`Environment '${this.environment}' not found in config`);
    this.emit('init');
    return this.initSshPool();
  }
  /**
   * Initialize events.
   */


  initializeEvents() {
    this.on('task_start', e => {
      // Specific log for noop functions.
      if (this.tasks[e.task].fn.toString() === 'function () {}') return;
      this.log('\nRunning', `'${_chalk.default.cyan(e.task)}' task...`);
    });
    this.on('task_stop', e => {
      const task = this.tasks[e.task]; // Specific log for noop functions.

      if (task.fn.toString() === 'function () {}') {
        this.log('Finished', `'${_chalk.default.cyan(e.task)}'`, _chalk.default.cyan(`[ ${task.dep.join(', ')} ]`));
        return;
      }

      const time = (0, _prettyHrtime.default)(e.hrDuration);
      this.log('Finished', `'${_chalk.default.cyan(e.task)}'`, 'after', _chalk.default.magenta(time));
    });
    this.on('task_err', e => {
      const msg = formatError(e);
      const time = (0, _prettyHrtime.default)(e.hrDuration);
      this.log(`'${_chalk.default.cyan(e.task)}'`, _chalk.default.red('errored after'), _chalk.default.magenta(time));
      this.log(msg);
    });
    this.on('task_not_found', err => {
      this.log(_chalk.default.red(`Task '${err.task}' is not in your shipitfile`));
      this.log('Please check the documentation for proper shipitfile formatting');
    });
  }
  /**
   * Initialize SSH connections.
   *
   * @returns {Shipit} for chaining
   */


  initSshPool() {
    if (!this.config.servers) throw new Error('Servers not filled');
    const servers = Array.isArray(this.config.servers) ? this.config.servers : [this.config.servers];

    const options = _extends({}, this.options, {
      key: this.config.key,
      asUser: this.config.asUser,
      strict: this.config.strict,
      verbosityLevel: this.config.verboseSSHLevel === undefined ? 0 : this.config.verboseSSHLevel
    });

    this.pool = new _sshPool.ConnectionPool(servers, options);
    this.emit('init:after_ssh_pool');
    return this;
  }
  /**
   * Initialize shipit configuration.
   *
   * @param {object} config
   * @returns {Shipit} for chaining
   */


  initConfig(config = {}) {
    this.globalConfig = config;
    this.config = _extends({}, config.default, {}, config[this.environment]);
    return this;
  }
  /**
   * Run a command locally.
   *
   * @param {string} command
   * @param {object} options
   * @returns {ChildObject}
   */


  local(command, _ref = {}) {
    let stdout = _ref.stdout,
        stderr = _ref.stderr,
        cmdOptions = _objectWithoutPropertiesLoose(_ref, ["stdout", "stderr"]);

    this.log('Running "%s" on local.', command);
    const prefix = '@ ';
    return (0, _sshPool.exec)(command, cmdOptions, child => {
      if (this.options.stdout) child.stdout.pipe(new _streamLineWrapper.default({
        prefix
      })).pipe(this.options.stdout);
      if (this.options.stderr) child.stderr.pipe(new _streamLineWrapper.default({
        prefix
      })).pipe(this.options.stderr);
    });
  }
  /**
   * Run a command remotely.
   *
   * @param {string} command
   * @returns {ExecResult}
   * @throws {ExecError}
   */


  remote(command, options) {
    var _this = this;

    return _asyncToGenerator(function* () {
      return _this.pool.run(command, options);
    })();
  }
  /**
   * Copy from local to remote or vice versa.
   *
   * @param {string} src
   * @param {string} dest
   * @returns {ExecResult|MultipleExecResult}
   * @throws {ExecError}
   */


  remoteCopy(src, dest, options) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const defaultOptions = {
        ignores: _this2.config && _this2.config.ignores ? _this2.config.ignores : [],
        rsync: _this2.config && _this2.config.rsync ? _this2.config.rsync : []
      };

      const copyOptions = _extends({}, defaultOptions, {}, options);

      return _this2.pool.copy(src, dest, copyOptions);
    })();
  }
  /**
   * Run a copy from the local to the remote using rsync.
   * All exec options are also available.
   *
   * @see https://nodejs.org/dist/latest-v8.x/docs/api/child_process.html#child_process_child_process_exec_command_options_callback
   *
   * @param {string} src
   * @param {string} dest
   * @param {object} [options] Options
   * @param {string[]} [options.ignores] Specify a list of files to ignore.
   * @param {string[]|string} [options.rsync] Specify a set of rsync arguments.
   * @returns {MultipleExecResult}
   * @throws {ExecError}
   */


  copyToRemote(src, dest, options) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      const defaultOptions = {
        ignores: _this3.config && _this3.config.ignores ? _this3.config.ignores : [],
        rsync: _this3.config && _this3.config.rsync ? _this3.config.rsync : []
      };

      const copyOptions = _extends({}, defaultOptions, {}, options);

      return _this3.pool.copyToRemote(src, dest, copyOptions);
    })();
  }
  /**
   * Run a copy from the remote to the local using rsync.
   * All exec options are also available.
   *
   * @see https://nodejs.org/dist/latest-v8.x/docs/api/child_process.html#child_process_child_process_exec_command_options_callback
   * @param {string} src Source
   * @param {string} dest Destination
   * @param {object} [options] Options
   * @param {string[]} [options.ignores] Specify a list of files to ignore.
   * @param {string[]|string} [options.rsync] Specify a set of rsync arguments.
   * @returns {MultipleExecResult}
   * @throws {ExecError}
   */


  copyFromRemote(src, dest, options) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const defaultOptions = {
        ignores: _this4.config && _this4.config.ignores ? _this4.config.ignores : [],
        rsync: _this4.config && _this4.config.rsync ? _this4.config.rsync : []
      };

      const copyOptions = _extends({}, defaultOptions, {}, options);

      return _this4.pool.copyFromRemote(src, dest, copyOptions);
    })();
  }
  /**
   * Log.
   *
   * @see console.log
   */


  log(...args) {
    this.options.log(...args);
  }
  /**
   * Create a new blocking task.
   *
   * @see shipit.task
   */


  blTask(name, ...rest) {
    this.task(name, ...rest);
    const task = this.tasks[name];
    task.blocking = true;
    return task;
  }
  /**
   * Test if we are ready to run a task.
   * Implement blocking task.
   */


  _readyToRunTask(...args) {
    if (Object.keys(this.tasks).some(key => {
      const task = this.tasks[key];
      return task.running === true && task.blocking === true;
    })) return false;
    return super._readyToRunTask(...args); // eslint-disable-line no-underscore-dangle
  }

}

var _default = Shipit;
exports.default = _default;