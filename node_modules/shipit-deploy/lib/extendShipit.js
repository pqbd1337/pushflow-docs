"use strict";

exports.__esModule = true;
exports.default = void 0;

var _posix = _interopRequireDefault(require("path2/posix"));

var _lodash = _interopRequireDefault(require("lodash"));

var _util = _interopRequireDefault(require("util"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * Compute the current release dir name.
 *
 * @param {object} result
 * @returns {string}
 */
function computeReleases(result) {
  if (!result.stdout) return null; // Trim last breakline.

  const dirs = result.stdout.replace(/\n$/, ''); // Convert releases to an array.

  return dirs.split('\n');
}
/**
 * Test if all values are equal.
 *
 * @param {*[]} values
 * @returns {boolean}
 */


function equalValues(values) {
  return values.every(value => _lodash.default.isEqual(value, values[0]));
}
/**
 * Compute the current release dir name.
 *
 * @param {object} result
 * @returns {string}
 */


function computeReleaseDirname(result) {
  if (!result.stdout) return null; // Trim last breakline.

  const target = result.stdout.replace(/\n$/, '');
  return target.split(_posix.default.sep).pop();
}

function validateConfig(config) {
  const errors = [];

  if (!config.deployTo) {
    errors.push("Config must include a 'deployTo' property");
  }

  if (errors.length) {
    console.log(errors);
    throw new Error('Config is invalid. Please refer to errors above and try again.');
  }
}

function extendShipit(shipit) {
  /* eslint-disable no-param-reassign */
  validateConfig(shipit.config);
  shipit.currentPath = _posix.default.join(shipit.config.deployTo, 'current');
  shipit.releasesPath = _posix.default.join(shipit.config.deployTo, 'releases');

  const config = _extends({
    branch: 'master',
    keepReleases: 5,
    shallowClone: true,
    keepWorkspace: false,
    gitLogFormat: '%h: %s - %an'
  }, shipit.config);

  Object.assign(shipit.config, config);
  /* eslint-enable no-param-reassign */

  const Shipit = shipit.constructor;
  /**
   * Return the current release dirname.
   */

  Shipit.prototype.getCurrentReleaseDirname =
  /*#__PURE__*/
  function () {
    var _getCurrentReleaseDirname = _asyncToGenerator(function* () {
      const results = (yield this.remote(_util.default.format('if [ -h %s ]; then readlink %s; fi', this.currentPath, this.currentPath))) || [];
      const releaseDirnames = results.map(computeReleaseDirname);

      if (!equalValues(releaseDirnames)) {
        throw new Error('Remote servers are not synced.');
      }

      if (!releaseDirnames[0]) {
        this.log('No current release found.');
        return null;
      }

      return releaseDirnames[0];
    });

    function getCurrentReleaseDirname() {
      return _getCurrentReleaseDirname.apply(this, arguments);
    }

    return getCurrentReleaseDirname;
  }();
  /**
   * Return all remote releases (newest first)
   */


  Shipit.prototype.getReleases =
  /*#__PURE__*/
  function () {
    var _getReleases = _asyncToGenerator(function* () {
      const results = yield this.remote(`ls -r1 ${this.releasesPath}`);
      const releases = results.map(computeReleases);

      if (!equalValues(releases)) {
        throw new Error('Remote servers are not synced.');
      }

      return releases[0];
    });

    function getReleases() {
      return _getReleases.apply(this, arguments);
    }

    return getReleases;
  }();
  /**
   * Return SHA from remote REVISION file.
   *
   * @param {string} releaseDir Directory name of the relesase dir (YYYYMMDDHHmmss).
   */


  Shipit.prototype.getRevision =
  /*#__PURE__*/
  function () {
    var _getRevision = _asyncToGenerator(function* (releaseDir) {
      const file = _posix.default.join(this.releasesPath, releaseDir, 'REVISION');

      const response = yield this.remote(`if [ -f ${file} ]; then cat ${file} 2>/dev/null; fi;`);
      return response[0].stdout.trim();
    });

    function getRevision(_x) {
      return _getRevision.apply(this, arguments);
    }

    return getRevision;
  }();

  Shipit.prototype.getPendingCommits =
  /*#__PURE__*/
  function () {
    var _getPendingCommits = _asyncToGenerator(function* () {
      const currentReleaseDirname = yield this.getCurrentReleaseDirname();
      if (!currentReleaseDirname) return null;
      const deployedRevision = yield this.getRevision(currentReleaseDirname);
      if (!deployedRevision) return null;
      const res = yield this.local('git remote', {
        cwd: this.config.workspace
      });
      const remotes = res && res.stdout ? res.stdout.split(/\s/) : [];
      if (remotes.length < 1) return null; // Compare against currently undeployed revision

      const compareRevision = `${remotes[0]}/${this.config.branch}`;
      const response = yield this.local(`git log --pretty=format:"${shipit.config.gitLogFormat}" ${deployedRevision}..${compareRevision}`, {
        cwd: shipit.workspace
      });
      const commits = response.stdout.trim();
      return commits || null;
    });

    function getPendingCommits() {
      return _getPendingCommits.apply(this, arguments);
    }

    return getPendingCommits;
  }();
}

var _default = extendShipit;
exports.default = _default;